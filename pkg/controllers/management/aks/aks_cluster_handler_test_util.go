package aks

import (
	"embed"
	"time"

	"github.com/ghodss/yaml"
	v1 "github.com/rancher/aks-operator/pkg/apis/aks.cattle.io/v1"
	"github.com/rancher/rancher/pkg/controllers/management/clusteroperator"
	mgmtv3 "github.com/rancher/rancher/pkg/generated/norman/management.cattle.io/v3"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/mock"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/util/json"
	"k8s.io/client-go/dynamic"
)

//go:embed test/*
var testFs embed.FS

// initialize mockAksOperatorController struct from autogenerated mock code

type mockAksOperatorController struct {
	aksOperatorController
	mock.Mock
}

func getMockAksOperatorController(clusterState string) mockAksOperatorController {
	var dynamicClient dynamic.NamespaceableResourceInterface

	switch clusterState {
	case "default":
		dynamicClient = MockNamespaceableResourceInterfaceDefault{}
	case "create":
		dynamicClient = MockNamespaceableResourceInterfaceCreate{}
	case "active":
		dynamicClient = MockNamespaceableResourceInterfaceActive{}
	case "update":
		dynamicClient = MockNamespaceableResourceInterfaceUpdate{}
	case "akscc":
		dynamicClient = MockNamespaceableResourceInterfaceAKSCC{}
	default:
		dynamicClient = nil
	}

	return mockAksOperatorController{
		aksOperatorController: aksOperatorController{
			OperatorController: clusteroperator.OperatorController{
				ClusterEnqueueAfter:  func(name string, duration time.Duration){},
				SecretsCache:         nil,
				Secrets:              nil,
				TemplateCache:        nil,
				ProjectCache:         nil,
				AppLister:            nil,
				AppClient:            nil,
				NsClient:             nil,
				ClusterClient:        MockClusterClient{},
				CatalogManager:       nil,
				SystemAccountManager: nil,
				DynamicClient:        dynamicClient,
				ClientDialer: 		  MockFactory{},
				Discovery:            MockDiscovery{},
			},
			secretClient: nil,
		},
		Mock: mock.Mock{},
	}
}

// test setInitialUpstreamSpec

func (m *mockAksOperatorController) setInitialUpstreamSpec(cluster *mgmtv3.Cluster) (*mgmtv3.Cluster, error) {
	logrus.Infof("setting initial upstreamSpec on cluster [%s]", cluster.Name)

	// mock
	upstreamSpec := &v1.AKSClusterConfigSpec{}

	cluster = cluster.DeepCopy()
	cluster.Status.AKSStatus.UpstreamSpec = upstreamSpec
	return m.ClusterClient.Update(cluster)
}

// utility

func getMockV3Cluster(filename string) (mgmtv3.Cluster, error) {
	var mockCluster mgmtv3.Cluster

	// Read the embedded file
	cluster, err := testFs.ReadFile(filename); if err != nil {
		return mockCluster, err
	}
	// Unmarshal cluster yaml into a management v3 cluster object
	err = yaml.Unmarshal(cluster, &mockCluster); if err != nil {
		return mockCluster, err
	}

	return mockCluster, nil
}

func getMockAksClusterConfig(filename string) (*unstructured.Unstructured, error) {
	var aksClusterConfig *unstructured.Unstructured

	// Read the embedded file
	bytes, err := testFs.ReadFile(filename); if err != nil {
		return aksClusterConfig, err
	}
	// Unmarshal json into an unstructured cluster config object
	err = json.Unmarshal(bytes, &aksClusterConfig); if err != nil {
		return aksClusterConfig, err
	}

	return aksClusterConfig, nil
}
